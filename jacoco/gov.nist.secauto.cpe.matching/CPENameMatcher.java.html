<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CPENameMatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CPE 2.3 Reference Implementation</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.cpe.matching</a> &gt; <span class="el_source">CPENameMatcher.java</span></div><h1>CPENameMatcher.java</h1><pre class="source lang-java linenums">/**
 * Portions of this software was developed by employees of the National Institute
 * of Standards and Technology (NIST), an agency of the Federal Government and is
 * being made available as a public service. Pursuant to title 17 United States
 * Code Section 105, works of NIST employees are not subject to copyright
 * protection in the United States. This software may be subject to foreign
 * copyright. Permission in the United States and in foreign countries, to the
 * extent that NIST may hold copyright, to use, copy, modify, create derivative
 * works, and distribute this software and its documentation without fee is hereby
 * granted on a non-exclusive basis, provided that this notice and disclaimer
 * of warranty appears in all copies.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS' WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND FREEDOM FROM
 * INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL CONFORM TO THE
 * SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE ERROR FREE.  IN NO EVENT
 * SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT,
 * INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM,
 * OR IN ANY WAY CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT, OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY PERSONS OR
 * PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED FROM, OR AROSE OUT
 * OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.
 */
// Copyright (c) 2011, The MITRE Corporation

// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice, this list
//      of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright notice, this
//      list of conditions and the following disclaimer in the documentation and/or other
//      materials provided with the distribution.
//    * Neither the name of The MITRE Corporation nor the names of its contributors may be
//      used to endorse or promote products derived from this software without specific
//      prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
// SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
// OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
// TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package gov.nist.secauto.cpe.matching;

import gov.nist.secauto.cpe.common.LogicalValue;
import gov.nist.secauto.cpe.common.Utilities;
import gov.nist.secauto.cpe.common.WellFormedName;
import gov.nist.secauto.cpe.common.WellFormedName.Attribute;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * The CPENameMatcher is an implementation of the CPE Matching algorithm, as specified in the CPE
 * Matching Standard version 2.3.
 * 
 * @see &lt;a href= &quot;https://doi.org/10.6028/NIST.IR.7696&quot;&gt;NISTIR 7696 Section 7&lt;/a&gt;
 * 
 * @author &lt;a href=&quot;mailto:jkraunelis@mitre.org&quot;&gt;Joshua Kraunelis&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:david.waltermire@nist.gov&quot;&gt;David Waltermire&lt;/a&gt;
 */
public class CPENameMatcher {
  private CPENameMatcher() {
    // disable construction
  }

  /**
   * Tests two Well Formed Names for disjointness.
   * 
   * @param source
   *          Source WFN
   * @param target
   *          Target WFN
   * @return true if the names are disjoint, false otherwise
   */
  public static boolean isDisjoint(WellFormedName source, WellFormedName target) {
    // if any pairwise comparison is disjoint, the names are disjoint.
<span class="fc" id="L87">    Map&lt;WellFormedName.Attribute, Relation&gt; resultList = compareWFNs(source, target);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">    for (Relation result : resultList.values()) {</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">      if (Relation.DISJOINT.equals(result)) {</span>
<span class="fc" id="L90">        return true;</span>
      }
<span class="fc" id="L92">    }</span>
<span class="fc" id="L93">    return false;</span>
  }

  /**
   * Tests two Well Formed Names for equality.
   * 
   * @param source
   *          Source WFN
   * @param target
   *          Target WFN
   * @return true if the names are equal, false otherwise
   */
  public static boolean isEqual(WellFormedName source, WellFormedName target) {
    // if every pairwise comparison is equal, the names are equal.
<span class="fc" id="L107">    Map&lt;WellFormedName.Attribute, Relation&gt; resultList = compareWFNs(source, target);</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">    for (Relation result : resultList.values()) {</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">      if (!(Relation.EQUAL.equals(result))) {</span>
<span class="fc" id="L110">        return false;</span>
      }
<span class="fc" id="L112">    }</span>
<span class="nc" id="L113">    return true;</span>
  }

  /**
   * Tests if the target Well Formed Name is a subset of the source Well Formed Name.
   * 
   * @param source
   *          Source WFN
   * @param target
   *          Target WFN
   * @return true if the target is a subset of the source, false otherwise
   */
  public static boolean isSubset(WellFormedName source, WellFormedName target) {
    // if any comparison is anything other than subset or equal, then target is
    // not a subset of source.
<span class="fc" id="L128">    Map&lt;WellFormedName.Attribute, Relation&gt; resultList = compareWFNs(source, target);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">    for (Relation result : resultList.values()) {</span>
<span class="fc bfc" id="L130" title="All 4 branches covered.">      if (!(Relation.SUBSET.equals(result)) &amp;&amp; !(Relation.EQUAL.equals(result))) {</span>
<span class="fc" id="L131">        return false;</span>
      }
<span class="fc" id="L133">    }</span>
<span class="fc" id="L134">    return true;</span>
  }

  /**
   * Tests if the target Well Formed name is a superset of the source Well Formed Name.
   * 
   * @param source
   *          Source WFN
   * @param target
   *          Target WFN
   * @return true if the target is a superset of the source, false otherwise
   */
  public static boolean isSuperset(WellFormedName source, WellFormedName target) {
    // if any comparison is anything other than superset or equal, then target is
    // not
    // a superset of source.
<span class="fc" id="L150">    Map&lt;WellFormedName.Attribute, Relation&gt; resultList = compareWFNs(source, target);</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">    for (Relation result : resultList.values()) {</span>
<span class="pc bpc" id="L152" title="1 of 4 branches missed.">      if ((!Relation.SUPERSET.equals(result)) &amp;&amp; (!Relation.EQUAL.equals(result))) {</span>
<span class="fc" id="L153">        return false;</span>
      }
<span class="fc" id="L155">    }</span>
<span class="nc" id="L156">    return true;</span>
  }

  /**
   * Compares each attribute value pair in two Well Formed Names.
   * 
   * @param source
   *          Source WFN
   * @param target
   *          Target WFN
   * @return A Hashtable mapping attribute string to attribute value Relation
   */
  public static Map&lt;WellFormedName.Attribute, Relation&gt; compareWFNs(WellFormedName source, WellFormedName target) {
<span class="fc" id="L169">    Map&lt;WellFormedName.Attribute, Relation&gt; result</span>
<span class="fc" id="L170">        = new LinkedHashMap&lt;WellFormedName.Attribute, Relation&gt;(Attribute.values().length);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">    for (WellFormedName.Attribute attribute : Attribute.values()) {</span>
<span class="fc" id="L172">      result.put(attribute, compare(source.get(attribute), target.get(attribute)));</span>
    }
<span class="fc" id="L174">    return result;</span>
  }

  /**
   * Compares an attribute value pair.
   * 
   * @param source
   *          Source attribute value.
   * @param target
   *          Target attribute value.
   * @return The relation between the two attribute values.
   */
  private static Relation compare(Object source, Object target) {
    // matching is case insensitive, convert strings to lowercase.
<span class="fc bfc" id="L188" title="All 2 branches covered.">    if (isString(source)) {</span>
<span class="fc" id="L189">      source = Utilities.toLowercase((String) source);</span>
    }
<span class="fc bfc" id="L191" title="All 2 branches covered.">    if (isString(target)) {</span>
<span class="fc" id="L192">      target = Utilities.toLowercase((String) target);</span>
    }

    // Unquoted wildcard characters yield an undefined result.
<span class="pc bpc" id="L196" title="1 of 4 branches missed.">    if (isString(target) &amp;&amp; Utilities.containsWildcards((String) target)) {</span>
<span class="nc" id="L197">      return Relation.UNDEFINED;</span>
    }
    // If source and target values are equal, then result is equal.
<span class="fc bfc" id="L200" title="All 2 branches covered.">    if (source.equals(target)) {</span>
<span class="fc" id="L201">      return Relation.EQUAL;</span>
    }

    // Check to see if source or target are Logical Values.
<span class="fc" id="L205">    LogicalValue lvSource = null;</span>
<span class="fc" id="L206">    LogicalValue lvTarget = null;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">    if (source instanceof LogicalValue) {</span>
<span class="fc" id="L208">      lvSource = (LogicalValue) source;</span>
    }
<span class="fc bfc" id="L210" title="All 2 branches covered.">    if (target instanceof LogicalValue) {</span>
<span class="fc" id="L211">      lvTarget = (LogicalValue) target;</span>
    }

    // If Logical Values are equal, result is equal.
<span class="pc bpc" id="L215" title="1 of 6 branches missed.">    if (lvSource != null &amp;&amp; lvTarget != null &amp;&amp; lvSource.equals(lvTarget)) {</span>
<span class="nc" id="L216">      return Relation.EQUAL;</span>
    }

    // If source value is ANY, result is a superset.
<span class="pc bpc" id="L220" title="1 of 4 branches missed.">    if (lvSource != null &amp;&amp; LogicalValue.ANY.equals(lvSource)) {</span>
<span class="fc" id="L221">      return Relation.SUPERSET;</span>
    }
    // If target value is ANY, result is a subset.
<span class="fc bfc" id="L224" title="All 4 branches covered.">    if (lvTarget != null &amp;&amp; LogicalValue.ANY.equals(lvTarget)) {</span>
<span class="fc" id="L225">      return Relation.SUBSET;</span>
    }
    // If source or target is NA, result is disjoint.
<span class="pc bpc" id="L228" title="3 of 4 branches missed.">    if (lvSource != null &amp;&amp; LogicalValue.NA.equals(lvSource)) {</span>
<span class="nc" id="L229">      return Relation.DISJOINT;</span>
    }

<span class="pc bpc" id="L232" title="1 of 4 branches missed.">    if (lvTarget != null &amp;&amp; LogicalValue.NA.equals(lvTarget)) {</span>
<span class="fc" id="L233">      return Relation.DISJOINT;</span>
    }
    // only Strings will get to this point, not LogicalValues
<span class="fc" id="L236">    return compareStrings((String) source, (String) target);</span>
  }

  /**
   * Compares a source string to a target string, and addresses the condition in which the source
   * string includes unquoted special characters. It performs a simple regular expression match, with
   * the assumption that (as required) unquoted special characters appear only at the beginning and/or
   * the end of the source string. It also properly differentiates between unquoted and quoted special
   * characters.
   * 
   * @return Relation between source and target Strings.
   */
  private static Relation compareStrings(String source, String target) {
<span class="fc" id="L249">    int start = 0;</span>
<span class="fc" id="L250">    int end = Utilities.strlen(source);</span>
<span class="fc" id="L251">    int begins = 0;</span>
<span class="fc" id="L252">    int ends = 0;</span>

<span class="pc bpc" id="L254" title="1 of 2 branches missed.">    if (Utilities.substr(source, 0, 1).equals(&quot;*&quot;)) {</span>
<span class="nc" id="L255">      start = 1;</span>
<span class="nc" id="L256">      begins = -1;</span>
    } else {
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">      while ((start &lt; Utilities.strlen(source)) &amp;&amp; (Utilities.substr(source, start, start + 1).equals(&quot;?&quot;))) {</span>
<span class="nc" id="L259">        start = start + 1;</span>
<span class="nc" id="L260">        begins = begins + 1;</span>
      }
    }
<span class="pc bpc" id="L263" title="2 of 4 branches missed.">    if ((Utilities.substr(source, end - 1, end).equals(&quot;*&quot;)) &amp;&amp; (isEvenWildcards(source, end - 1))) {</span>
<span class="fc" id="L264">      end = end - 1;</span>
<span class="fc" id="L265">      ends = -1;</span>
    } else {
<span class="nc bnc" id="L267" title="All 6 branches missed.">      while ((end &gt; 0) &amp;&amp; Utilities.substr(source, end - 1, end).equals(&quot;?&quot;) &amp;&amp; (isEvenWildcards(source, end - 1))) {</span>
<span class="nc" id="L268">        end = end - 1;</span>
<span class="nc" id="L269">        ends = ends + 1;</span>
      }
    }

<span class="fc" id="L273">    source = Utilities.substr(source, start, end);</span>

<span class="fc" id="L275">    int index = -1;</span>
<span class="fc" id="L276">    int leftover = Utilities.strlen(target);</span>
<span class="fc" id="L277">    Relation retval = Relation.DISJOINT;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">    while (leftover &gt; 0) {</span>
<span class="fc" id="L279">      index = Utilities.indexOf(target, source, index + 1);</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">      if (index == -1) {</span>
<span class="nc" id="L281">        break;</span>
      }
<span class="fc" id="L283">      int escapes = Utilities.countEscapeCharacters(target, 0, index);</span>
<span class="pc bpc" id="L284" title="5 of 6 branches missed.">      if ((index &gt; 0) &amp;&amp; (begins != -1) &amp;&amp; (begins &lt; (index - escapes))) {</span>
<span class="nc" id="L285">        break;</span>
      }
<span class="fc" id="L287">      escapes = Utilities.countEscapeCharacters(target, index + 1, Utilities.strlen(target));</span>
<span class="fc" id="L288">      leftover = Utilities.strlen(target) - index - escapes - Utilities.strlen(source);</span>
<span class="pc bpc" id="L289" title="4 of 6 branches missed.">      if ((leftover &gt; 0) &amp;&amp; ((ends != -1) &amp;&amp; (leftover &gt; ends))) {</span>
<span class="nc" id="L290">        continue;</span>
      } else {
<span class="fc" id="L292">        retval = Relation.SUPERSET;</span>
<span class="fc" id="L293">        break;</span>
      }
    }
<span class="fc" id="L296">    return retval;</span>
  }

  /**
   * Searches a string for the backslash character.
   * 
   * @param str
   *          string to search in
   * @param idx
   *          end index
   * @return true if the number of backslash characters is even, false if odd
   */
  private static boolean isEvenWildcards(String str, int idx) {
<span class="fc" id="L309">    int result = 0;</span>
<span class="pc bpc" id="L310" title="2 of 4 branches missed.">    while ((idx &gt; 0) &amp;&amp; (Utilities.strchr(str, '\\', idx - 1)) != -1) {</span>
<span class="nc" id="L311">      idx = idx - 1;</span>
<span class="nc" id="L312">      result = result + 1;</span>
    }
<span class="fc" id="L314">    return Utilities.isEvenNumber(result);</span>
  }

  /**
   * Tests if an Object is an instance of the String class.
   * 
   * @param arg
   *          the Object to test
   * @return true if arg is a String, false if not
   */
  private static boolean isString(Object arg) {
<span class="fc bfc" id="L325" title="All 2 branches covered.">    if (arg instanceof String) {</span>
<span class="fc" id="L326">      return true;</span>
    } else {
<span class="fc" id="L328">      return false;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>